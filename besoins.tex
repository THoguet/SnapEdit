\documentclass[a4paper,12pt]{article}
\usepackage[frenchb]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc} 
\usepackage{lmodern}
\usepackage{mathptmx}

\usepackage{amsmath}
\usepackage{etoolbox}
\usepackage{float}
\usepackage{geometry}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Besoin PDL},
    pdfpagemode=FullScreen,
    }
\usepackage{graphicx}
%\usepackage[disable]{todonotes}
\usepackage{todonotes}
\usepackage{titlesec}
\titleformat*{\section}{\Large\bfseries\sffamily}
\titleformat*{\subsection}{\large\bfseries\sffamily}
\titleformat*{\subsubsection}{\itshape\subsubsectionfont}

\geometry{margin=2cm}

\newcounter{besoin}

% Descriptif des besoins:
% 1 - Label du besoin pour référencement 
% 2 - Titre du besoin
% 3 - Description
% 4 - Gestion d'erreurs
% 5 - Spécifications tests
\newcommand{\besoin}[5]{%
  \refstepcounter{besoin}%
  \fbox{\parbox{0.95\linewidth}{%
    \begin{center}\label{besoin:#1}\textbf{\sffamily Besoin~\thebesoin~: #2}\end{center}
    \ifstrempty{#3}{}{\textbf{Description~:} #3\par}
    \vspace{0.5em}
    \ifstrempty{#4}{}{\textbf{Gestion d'erreurs~:} #4\par}
    \vspace{0.5em}
    \ifstrempty{#5}{}{\textbf{Tests~:} #5\par}
  }}
}

\newcommand{\refBesoin}[1]{%
  Besoin~\ref{besoin:#1}%
}

\title{\sffamily \textbf{Projet de Développement Logiciel}}
\author{L3 Informatique -- Université de Bordeaux}
\date{}

\begin{document}

\maketitle

\section{Introduction}

Ce document présente les extensions pour le projet PDL

\section{Extensions}

\subsection{BackEnd}

\besoin{backend: listAlgo}
{Transférer la liste des algorithmes implementés}
{
  La liste des algorithmes disponible sur le serveur doit être envoyée par le serveur lorsqu'il reçoit une requête \verb!GET! à l'adresse \verb!/algorithms!.

  Le résultat sera fourni au format \verb!JSON!, sous la forme d'un tableau
  contenant pour chaque image un objet avec les informations suivantes :
  \begin{description}
  \item[Name:] Le nom d'affichage de l'algorithme (type \verb!string!)
  \item[Path:] Le point d'acces de l'algorithme \verb!/images?algorithm=<path>! (type \verb!string!)
  \item[Parameters] Une liste de Parameters (type \verb!List<Parameters>!) ci dessous spécification Parameters
  \begin{description}
    \item[type:] Le type de l'input ("select", "range") (type \verb!string!)
    \item[Name:] Le point d'acces du parametre \verb!/images?algorithm=*algo*\&<name>=*?*! (type \verb!string!)
    \item[displayName:] Le nom d'affichage du paramètre (type \verb!string!)
    \item[options:] le nom et la valeur associé à l'option de l'input (type \verb!string!)
  \end{description}
  \end{description}
}
{}
{}

\besoin{backend:selectBorder}
{Choisir les type de bordure pour les filtres}
{
  Les différentes façons dont les bords sont gérés par l'algorithme de convolution sont maintenant modifiable au choix parmis : 
  \begin{description}
  \item[SKIP:] les bords ne sont pas traités.
  \item[NORMALIZED:] le masque est normalisé pour ne prendre en compte que les valeurs au sein de l'image.
  \item[EXTENDED:] les pixels du bord sont étendus hors des limites, par exemple get(-1,0) et get(-2, 0) deviennent get(0,0).
  \item[REFLECT:] les accès hors de l'image sont réfléchis pour rester dans l'image, par exemple get(0,-2) devient get(0,2)
  \end{description}
}
{}
{}


\besoin{backend:cropimages}
{Rogner des images}
{
  Une image peut être rognée afin de créer une nouvelle image dont le contenu dépend de la zone de rognage choisie. L'algorithme prendra 5 paramètres : 
  \begin{description}
  \item[img : ] L'image d'origine
  \item[xMin : ] L'abscisse du pixel au coin haut gauche
  \item[yMin : ] L'ordonnée du pixel au coin haut gauche
  \item[xMax : ] L'abscisse du pixel au coin bas droit
  \item[yMax : ] L'ordonnée du pixel au coin bas droit
  \end{description}
}
{}
{}


\besoin{backend:applyfilteroncroppedimage}
{Appliquer un filtre sur la selection de l'image}
{
  Lors de la sélection de n'importe quel algorithme, il est possible de l'appliquer sur une partie de l'image plutôt que sur son entièreté. Tous les algorithmes auront donc 4 paramètres en plus : 
  \begin{description}
  \item[xMin : ] L'abscisse du pixel au coin haut gauche
  \item[yMin : ] L'ordonnée du pixel au coin haut gauche
  \item[xMax : ] L'abscisse du pixel au coin bas droit
  \item[yMax : ] L'ordonnée du pixel au coin bas droit
  \end{description}
}
{}
{}

\besoin{backend:selectionColor}
{Appliquer un filtre de selection de couleur}
{
  L'algorithme prend une intervalle de couleur, il est possible de choisir si les pixels dont la couleur appartient à l'intervalle la voient changer (noir et blanc ou autre couleur) ou si elle est conservée. L'algorithme prend paramètres : 
  \begin{description}
  \item[img: ] L'image d'origine
  \item[hMin: ] la valeur de H minimum sur HSV
  \item[hMax:] la valeur de H maximum sur HSV  
  \item[newH:] IL FAUT CHANGER CA PARCE QU'ON PEUT PAS CHANGER UNE RANGE COULEUR EN UNE SEULE COULEUR CA FERAIT MOCHE MAIS PLUTOT CHOISIR DES RANGE DISPONIBLES PAR EXEMPLE (N&B, ROUGE, ORANGE, JAUNE, VERT, BLEU, VIOLET, etc...) 
  \end{description}
}
{}
{}

\besoin{backend:basicFilters}
{Ajout de filtres basiques }
{
  Ajout de quelques filtres basiques dont voici la liste: 
  \begin{description}
  \item[sharpness :] Filtre de netteté (sharpness filter) - pour augmenter la netteté des détails dans l'image
  \item[saturation :] Filtre de saturation (saturation filter) - pour augmenter ou diminuer l'intensité des couleurs dans l'image
  \item[vignette :] Filtre de vignette (vignette filter) - pour assombrir les bords de l'image et attirer l'attention sur le centre
  \item[grain :] Filtre de grain (grain filter) - pour ajouter un effet de bruit visuel pour donner à l'image une apparence plus granuleuse
  \item[sepia :] Filtre de sépia (sepia filter) - pour donner à l'image une teinte brunâtre vintage.
  \item[negative :] Filtre negatif (negative filter) - pour inverser les couleurs d'une image.
  \end{description} 
}
{}
{}
 
\besoin{backend:removeElementFromImage}
{Supprimer un element d'une image}
{
  Supprime une zone de l'image et la remplit selon le même principe que la convolution. Cet algorithme prend 6 paramètres : 
  \begin{description}
  \item[img:] L'image d'origine
  \item[xMin : ] L'abscisse du pixel au coin haut gauche
  \item[yMin : ] L'ordonnée du pixel au coin haut gauche
  \item[xMax : ] L'abscisse du pixel au coin bas droit
  \item[yMax : ] L'ordonnée du pixel au coin bas droit
  \item[fillingType : ] la façon de remplir la partie supprimée de l'image. Il y a type de remplissage : 
  \begin{description}
  \item[skip :] la partie supprimée n'est pas remplie, elle reste noire.
  \item[]
  \end{description}
  \end{description}
}
{}
{}

\subsection{FrontEnd}


\besoin{FrontEnd:ShowAlgo}
{Afficher les algorithmes fournis par le serveur}
{
  La liste des images présentes sur le serveur doit être envoyée par le serveur lorsqu'il reçoit une requête \verb!GET! à l'adresse \verb!/images!.

  Le résultat sera fourni au format \verb!JSON!, sous la forme d'un tableau
  contenant pour chaque image un objet avec les informations suivantes :
  \begin{description}
  \item[Id:] L'identifiant auquel est accessible l'image (type \verb!long!)
  \item[Name:] Le nom du fichier qui a servi à construire l'image (type \verb!string!)
  \item[Type:] Le type de l'image (type \verb!org.springframework.http.MediaType!) 
  \item[Size:] Une description de la taille de l'image, par exemple \verb!640*480*3! pour
    une image en couleur de $640 \times 480$ pixels (type \verb!string!)
  \end{description}
}
{}
{}


\besoin{FrontEnd:generateAnImage}
{Generer une image avec DALL-E}
{
  La liste des images présentes sur le serveur doit être envoyée par le serveur lorsqu'il reçoit une requête \verb!GET! à l'adresse \verb!/images!.

  Le résultat sera fourni au format \verb!JSON!, sous la forme d'un tableau
  contenant pour chaque image un objet avec les informations suivantes :
  \begin{description}
  \item[Id:] L'identifiant auquel est accessible l'image (type \verb!long!)
  \item[Name:] Le nom du fichier qui a servi à construire l'image (type \verb!string!)
  \item[Type:] Le type de l'image (type \verb!org.springframework.http.MediaType!) 
  \item[Size:] Une description de la taille de l'image, par exemple \verb!640*480*3! pour
    une image en couleur de $640 \times 480$ pixels (type \verb!string!)
  \end{description}
}
{}
{}


\besoin{FrontEnd:seeStatus}
{Voir l'avancement du traitement de l'image / d'un upload}
{
  La liste des images présentes sur le serveur doit être envoyée par le serveur lorsqu'il reçoit une requête \verb!GET! à l'adresse \verb!/images!.

  Le résultat sera fourni au format \verb!JSON!, sous la forme d'un tableau
  contenant pour chaque image un objet avec les informations suivantes :
  \begin{description}
  \item[Id:] L'identifiant auquel est accessible l'image (type \verb!long!)
  \item[Name:] Le nom du fichier qui a servi à construire l'image (type \verb!string!)
  \item[Type:] Le type de l'image (type \verb!org.springframework.http.MediaType!) 
  \item[Size:] Une description de la taille de l'image, par exemple \verb!640*480*3! pour
    une image en couleur de $640 \times 480$ pixels (type \verb!string!)
  \end{description}
}
{}
{}

\end{document}
