\documentclass[a4paper,12pt]{article}
\usepackage[frenchb]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc} 
\usepackage{lmodern}
\usepackage{mathptmx}

\usepackage{amsmath}
\usepackage{etoolbox}
\usepackage{float}
\usepackage{geometry}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Besoin PDL},
    pdfpagemode=FullScreen,
    }
\usepackage{graphicx}
%\usepackage[disable]{todonotes}
\usepackage{todonotes}
\usepackage{titlesec}
\titleformat*{\section}{\Large\bfseries\sffamily}
\titleformat*{\subsection}{\large\bfseries\sffamily}
\titleformat*{\subsubsection}{\itshape\subsubsectionfont}

\geometry{margin=2cm}

\newcounter{besoin}

% Descriptif des besoins:
% 1 - Label du besoin pour référencement 
% 2 - Titre du besoin
% 3 - Description
% 4 - Gestion d'erreurs
% 5 - Spécifications tests
\newcommand{\besoin}[5]{%
  \refstepcounter{besoin}%
  \fbox{\parbox{0.95\linewidth}{%
    \begin{center}\label{besoin:#1}\textbf{\sffamily Besoin~\thebesoin~: #2}\end{center}
    \ifstrempty{#3}{}{\textbf{Description~:} #3\par}
    \vspace{0.5em}
    \ifstrempty{#4}{}{\textbf{Gestion d'erreurs~:} #4\par}
    \vspace{0.5em}
    \ifstrempty{#5}{}{\textbf{Tests~:} #5\par}
  }}
}

\newcommand{\refBesoin}[1]{%
  Besoin~\ref{besoin:#1}%
}

\title{\sffamily \textbf{Projet de Développement Logiciel}}
\author{L3 Informatique -- Université de Bordeaux}
\date{}

\begin{document}

\maketitle

\section{Introduction}

Ce document présente les extensions pour le projet PDL.

\section{Extensions}

\subsection{BackEnd}

\besoin{backend: listAlgo}
{Transférer la liste des algorithmes implementés}
{
  La liste des algorithmes disponibles sur le serveur doit être envoyée par le serveur lorsqu'il reçoit une requête \verb!GET! à l'adresse \verb!/algorithms!.

  Le résultat sera fourni au format \verb!JSON!, sous la forme d'un tableau
  contenant pour chaque image un objet avec les informations suivantes :
  \begin{description}
  \item[Name:] Le nom d'affichage de l'algorithme (type \verb!string!)
  \item[Path:] Le point d'accès de l'algorithme \verb!/images?algorithm=<path>! (type \verb!string!)
  \item[Parameters] Une liste de paramètres (type \verb!List<Parameters>!) ci dessous spécification Parameters
  \begin{description}
    \item[Name:] Le nom d'affichage du paramètre (type \verb!string!)
    \item[Path:] Le point d'accès du paramètre \verb!/images?algorithm=*algo*\&<name>=*?*! (type \verb!string!)
    \item[type:] Le type de l'input ("select", "range", "boolean", "area", "color") (type \verb!string!)
    \item[Parameters:] Une liste de paramètres nécessaires pour l'algorithme. Dépend du type de paramètre. Les paramètres de type "range" ont besoin des paramètres min (type \verb!int!) , max (type \verb!int!) et step(type \verb!int!). Les paramètres de type "select" ont besoin d'un paramètre option (type \verb![string]!). Les paramètres de type "area" ont besoin d'un paramètre "cropImage" (type \verb!boolean!). Les autres paramètres n'ont pas besoin de paramètres supplémentaires.
  \end{description}
  \end{description}
}
{}
{}

\besoin{backend:selectBorder}
{Choisir les types de bordure pour les filtres}
{
  Les différentes façons dont les bords sont gérés par l'algorithme de convolution sont maintenant modifiable au choix parmi : 
  \begin{description}
  \item[SKIP:] Les bords ne sont pas traités.
  \item[NORMALIZED:] Le masque est normalisé pour ne prendre en compte que les valeurs au sein de l'image.
  \item[EXTENDED:] Les pixels du bord sont étendus hors des limites, par exemple get(-1,0) et get(-2, 0) deviennent get(0,0).
  \item[REFLECT:] Les accès hors de l'image sont réfléchis pour rester dans l'image, par exemple get(0,-2) devient get(0,2).
  \item[WRAP:] Quand on accède à un pixel hors de l'image, on enveloppe l'image, par exemple get(-1,0) devient get(width-1,0).
  \item[ZERO:] Tous les pixels de bords sont mis à 0 (noir).
  \end{description}
}
{}
{}


\besoin{backend:cropimages}
{Rogner des images}
{
  Une image peut être rognée afin de créer une nouvelle image dont le contenu dépend de la zone de rognage choisie. L'algorithme prendra 5 paramètres : 
  \begin{description}
  \item[img : ] L'image d'origine
  \item[xMin : ] L'abscisse du pixel au coin haut gauche
  \item[yMin : ] L'ordonnée du pixel au coin haut gauche
  \item[xMax : ] L'abscisse du pixel au coin bas droit
  \item[yMax : ] L'ordonnée du pixel au coin bas droit
  \end{description}
}
{}
{}


\besoin{backend:applyfilteroncroppedimage}
{Appliquer un filtre sur la selection de l'image}
{
  Lors de la sélection de n'importe quel algorithme, il est possible de l'appliquer sur une partie de l'image plutôt que sur son entièreté. Tous les algorithmes auront donc 4 paramètres en plus : 
  \begin{description}
  \item[xMin : ] L'abscisse du pixel au coin haut gauche
  \item[yMin : ] L'ordonnée du pixel au coin haut gauche
  \item[xMax : ] L'abscisse du pixel au coin bas droit
  \item[yMax : ] L'ordonnée du pixel au coin bas droit
  \end{description}
}
{}
{}

\besoin{backend:selectionColor}
{Appliquer un filtre de sélection de couleur}
{
  L'algorithme prend un intervalle de couleurs, il est possible de choisir si les pixels dont la couleur appartient à l'intervalle sont changés (noir et blanc ou autre couleur) ou si ils restent inchangés. L'algorithme prend en paramètres : 
  \begin{description}
  \item[img: ] L'image d'origine
  \item[hexOldColor: ] valeur hexadécimale de la couleur choisie
  \item[range: ] définit la gamme de couleur choisie, elle peut aller de 0 à 179
  \item[newColor: ] la couleur qui va être appliquée (ROUGE, JAUNE, VERT, BLEU, CYAN, MAGENTA) 
  \item[keep: ] booléen qui détermine si la range de couleur choisie est celle qui est changée, ou celle qui est modifiée.
  \end{description}
}
{}
{}

\besoin{backend:basicFilters}
{Ajout de filtres basiques }
{
  Ajout de quelques filtres basiques dont voici la liste: 
  \begin{description}
  \item[saturation :] Filtre de saturation (saturation filter) - pour augmenter ou diminuer l'intensité des couleurs dans l'image.
  \item[vignette :] Filtre de vignette (vignette filter) - pour assombrir les bords de l'image et attirer l'attention sur le centre.
  \item[grain :] Filtre de grain (grain filter) - pour ajouter un effet de bruit visuel pour donner à l'image une apparence plus granuleuse.
  \item[sepia :] Filtre de sépia (sepia filter) - pour donner à l'image une teinte brunâtre vintage.
  \item[negative :] Filtre négatif (negative filter) - pour inverser les couleurs d'une image.
  \end{description} 
}
{}
{}
 
\besoin{backend:removeElementFromImage}
{Supprimer un élement d'une image}
{
  Supprime une zone de l'image et la remplit selon le même principe que la convolution. Cet algorithme prend 6 paramètres : 
  \begin{description}
  \item[img:] L'image d'origine
  \item[xMin : ] L'abscisse du pixel au coin haut gauche
  \item[yMin : ] L'ordonnée du pixel au coin haut gauche
  \item[xMax : ] L'abscisse du pixel au coin bas droit
  \item[yMax : ] L'ordonnée du pixel au coin bas droit
  \item[fillingType : ] la façon de remplir la partie supprimée de l'image. Il y a type de remplissage : 
  \begin{description}
  \item[skip :] la partie supprimée n'est pas remplie, elle reste noire.
  \item[convolution :] la partie supprimée est remplie avec la convolution de l'image d'origine.
  \item[left :] la partie supprimée est remplie de façon similaire à ce qu'il y a à sa gauche.
  \item[right :] la partie supprimée est remplie de façon similaire à ce qu'il y a à sa droite.
  \item[top :] la partie supprimée est remplie de façon similaire à ce qu'il y a au dessus.
  \item[bottom :] la partie supprimée est remplie de façon similaire à ce qu'il y a en dessous.  
  \end{description}
  \end{description}
}
{}
{}

\subsection{FrontEnd}


\besoin{FrontEnd:ShowAlgo}
{Afficher les algorithmes fournis par le serveur}
{
  Le front doit pouvoir afficher les algorithmes donné par le backend (/algorithms).
  voir Besoin 1.
}
{}
{}


\besoin{FrontEnd:generateAnImage}
{Générer une image avec stableDiffusion}
{
  Avoir une page pour faire des requetes a un serveur StableDiffusion

  Les champs doivent etre les suivants :
  \begin{description}
  \item[Prompt:] Une zone de texte pour le prompt de l'image
  \item[Negative prompt:] Une zone de texte pour le prompt négatif de l'image
  \item[Hauteur:] Un sélecteur pour la hauteur de l'image
  \item[Largeur:] Un sélecteur pour la largeur de l'image
  \item[Steps:] Le nombre de steps lors de la génération
  \item[CFG scale:] Le niveau de liberté de l'IA
  \end{description}
}
{}
{}


\besoin{FrontEnd:seeStatus}
{Voir l'avancement du traitement de l'image / d'un upload / de la generation d'une image}
{
  Avoir un affichage clair de la progression d'un traitement d'image / de la génération d'une image ou d'un upload
}
{}
{}

\end{document}
